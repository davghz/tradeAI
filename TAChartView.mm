/**
 * TAChartView.mm
 * Generated by codex for module: chart_view
 */

#import "TACoinbaseAPI.h"
#import "TAPortfolio.h"
#import "TAChartView.h"
#import <float.h>

@interface TAChartView ()
@property (nonatomic, strong) NSArray *candleData;
@property (nonatomic, copy) NSString *timeframe;
@end

@implementation TAChartView

static double TACandleCloseValue(id candle) {
    if ([candle isKindOfClass:[NSDictionary class]]) {
        NSDictionary *dict = (NSDictionary *)candle;
        id closeVal = dict[@"close"] ?: dict[@"close_price"] ?: dict[@"price"];
        if ([closeVal isKindOfClass:[NSNumber class]]) {
            return [(NSNumber *)closeVal doubleValue];
        }
        if ([closeVal isKindOfClass:[NSString class]]) {
            return [(NSString *)closeVal doubleValue];
        }
        if ([closeVal isKindOfClass:[NSDictionary class]]) {
            id inner = ((NSDictionary *)closeVal)[@"value"] ?: ((NSDictionary *)closeVal)[@"amount"];
            if ([inner isKindOfClass:[NSNumber class]]) {
                return [(NSNumber *)inner doubleValue];
            }
            if ([inner isKindOfClass:[NSString class]]) {
                return [(NSString *)inner doubleValue];
            }
        }
        return NAN;
    }
    if ([candle isKindOfClass:[NSArray class]]) {
        NSArray *arr = (NSArray *)candle;
        if (arr.count >= 5) {
            id value = [arr lastObject];
            if ([value isKindOfClass:[NSNumber class]]) {
                return [(NSNumber *)value doubleValue];
            }
            if ([value isKindOfClass:[NSString class]]) {
                return [(NSString *)value doubleValue];
            }
        }
        return NAN;
    }
    if ([candle isKindOfClass:[NSNumber class]]) {
        return [(NSNumber *)candle doubleValue];
    }
    if ([candle isKindOfClass:[NSString class]]) {
        return [(NSString *)candle doubleValue];
    }
    return NAN;
}

- (instancetype)initWithFrame:(CGRect)frame {
    self = [super initWithFrame:frame];
    if (self) {
        self.backgroundColor = [UIColor blackColor];
        self.candleData = @[];
        self.timeframe = @"ONE_HOUR";
    }
    return self;
}

- (void)updateWithCandles:(NSArray *)candles {
    self.candleData = candles ?: @[];
    [self reloadData];
}

- (void)reloadData {
    [self setNeedsDisplay];
}

- (void)setTimeframe:(NSString *)timeframe {
    _timeframe = [timeframe copy];
    [self reloadData];
}

- (void)drawRect:(CGRect)rect {
    [super drawRect:rect];
    
    CGContextRef context = UIGraphicsGetCurrentContext();
    
    // Fill background
    CGContextSetFillColorWithColor(context, [UIColor blackColor].CGColor);
    CGContextFillRect(context, rect);
    
    // Draw grid
    CGContextSetStrokeColorWithColor(context, [UIColor darkGrayColor].CGColor);
    CGContextSetLineWidth(context, 0.5);
    
    for (int i = 0; i <= 4; i++) {
        CGFloat y = rect.size.height * i / 4;
        CGContextMoveToPoint(context, 0, y);
        CGContextAddLineToPoint(context, rect.size.width, y);
    }
    CGContextStrokePath(context);
    
    if (self.candleData.count == 0) {
        NSDictionary *attrs = @{
            NSFontAttributeName: [UIFont systemFontOfSize:12],
            NSForegroundColorAttributeName: [UIColor darkGrayColor]
        };
        NSString *text = @"No chart data";
        CGSize size = [text sizeWithAttributes:attrs];
        [text drawAtPoint:CGPointMake((rect.size.width - size.width) / 2.0,
                                      (rect.size.height - size.height) / 2.0)
           withAttributes:attrs];
        return;
    }

    // Build close price series
    NSMutableArray<NSNumber *> *closes = [NSMutableArray array];
    for (id candle in self.candleData) {
        double value = TACandleCloseValue(candle);
        if (isnan(value)) {
            continue;
        }
        [closes addObject:@(value)];
    }

    if (closes.count == 0) {
        return;
    }

    double minVal = DBL_MAX;
    double maxVal = DBL_MIN;
    for (NSNumber *num in closes) {
        double v = num.doubleValue;
        minVal = MIN(minVal, v);
        maxVal = MAX(maxVal, v);
    }

    if (minVal == maxVal) {
        minVal -= 1;
        maxVal += 1;
    }

    CGContextSetStrokeColorWithColor(context, [UIColor colorWithRed:0.2 green:0.9 blue:0.7 alpha:1.0].CGColor);
    CGContextSetLineWidth(context, 2.0);

    CGFloat padding = 6.0;
    CGFloat height = rect.size.height - padding * 2.0;
    CGFloat width = rect.size.width - padding * 2.0;
    NSUInteger count = closes.count;
    for (NSUInteger i = 0; i < count; i++) {
        double v = closes[i].doubleValue;
        CGFloat x = padding + ((CGFloat)i / (CGFloat)(count - 1)) * width;
        CGFloat normalized = (CGFloat)((v - minVal) / (maxVal - minVal));
        CGFloat y = padding + height - (normalized * height);
        if (i == 0) {
            CGContextMoveToPoint(context, x, y);
        } else {
            CGContextAddLineToPoint(context, x, y);
        }
    }
    CGContextStrokePath(context);
}

@end
